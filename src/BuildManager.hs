{-# OPTIONS_GHC -Wall #-}
module BuildManager where

import Control.Monad.Except (ExceptT, runExceptT)
import Control.Monad.State (StateT, liftIO, runStateT)
import qualified Control.Monad.State as State
import qualified Data.List as List
import qualified Data.Time.Clock.POSIX as Time
import qualified Elm.Compiler as Compiler
import qualified Elm.Compiler.Module as Module
import qualified Elm.Package as Pkg
import qualified Elm.Package.Paths as Path
import System.FilePath ((</>))
import System.IO (hPutStrLn, stderr)

import qualified Report
import qualified TheMasterPlan as TMP


-- CONFIGURATION

data Config = Config
    { _artifactDirectory :: FilePath
    , _files :: [FilePath]
    , _output :: Output
    , _autoYes :: Bool
    , _reportType :: Report.Type
    , _warn :: Bool
    , _docs :: Maybe FilePath
    }


data Output
    = Html FilePath
    | JS FilePath
    | DevNull


outputFilePath :: Config -> FilePath
outputFilePath config =
  case _output config of
    Html file -> file
    JS file -> file
    DevNull -> "/dev/null"


artifactDirectory :: FilePath
artifactDirectory =
    Path.stuffDirectory </> "build-artifacts" </> (Pkg.versionToString Compiler.version)


-- RUN A BUILD

type Task a =
  ExceptT Error (StateT [Phase] IO) a


run :: Task a -> IO (Either Error (a, Timeline))
run task =
  do  result <-
          runStateT (runExceptT (phase "elm-make" task)) []
      case result of
        (Right answer, [Phase _ start phases end]) ->
            return (Right (answer, Timeline start phases end))

        (Left err, _) ->
            return (Left err)

        (Right _, _) ->
            error "Something impossible happened when profiling elm-make."



-- TIMELINE

data Timeline = Timeline
    { _start :: Time.POSIXTime
    , _phases :: [Phase]
    , _end :: Time.POSIXTime
    }


data Phase = Phase
    { _tag :: String
    , _start_ :: Time.POSIXTime
    , _subphases :: [Phase]
    , _end_ :: Time.POSIXTime
    }


phase :: String -> Task a -> Task a
phase name task =
  do  phasesSoFar <- State.get
      State.put []
      start <- liftIO Time.getPOSIXTime
      result <- task
      end <- liftIO Time.getPOSIXTime
      State.modify' (\phases -> Phase name start (reverse phases) end : phasesSoFar)
      return result


timelineToString :: Timeline -> String
timelineToString (Timeline start phases end) =
  let
    duration = end - start
  in
    "\nOverall time: " ++ show duration ++ "\n"
    ++ concatMap (phaseToString duration 1) phases
    ++ "\n"


phaseToString :: Time.POSIXTime -> Int -> Phase -> String
phaseToString overallDuration indent (Phase tag start subphases end) =
  let
    duration = end - start
    percent = truncate (100 * duration / overallDuration) :: Int
  in
    '\n' : replicate (indent * 4) ' ' ++ show percent ++ "% - " ++ tag
    ++ concatMap (phaseToString duration (indent + 1)) subphases


-- ERRORS

data Error
    = CompilerErrors FilePath String [Compiler.Error]
    | CorruptedArtifact FilePath
    | Cycle [TMP.CanonicalModule]
    | PackageProblem String
    | MissingPackage Pkg.Name
    | ModuleNotFound Module.Name (Maybe Module.Name)
    | ModuleDuplicates
        { _name :: Module.Name
        , _parent :: Maybe Module.Name
        , _local :: [FilePath]
        , _foreign :: [Pkg.Name]
        }
    | ModuleName
        { _path :: FilePath
        , _expectedName :: Module.Name
        , _actualName :: Module.Name
        }


printError :: Error -> IO ()
printError err =
  case err of
    CompilerErrors path source errors ->
        do  isTerminal <- Report.checkIsTerminal
            mapM_ (Report.printError isTerminal Compiler.dummyLocalizer path source) errors

    CorruptedArtifact filePath ->
        hPutStrLn stderr $
          "Error reading build artifact " ++ filePath ++ "\n"
          ++ "\n"
          ++ "The file was generated by a previous build and may be outdated or corrupt.\n"
          ++ "Remove the file and try again."

    Cycle moduleCycle ->
        hPutStrLn stderr $
          "Your dependencies form a cycle:\n\n"
          ++ drawCycle moduleCycle
          ++ "\nYou may need to move some values to a new module to get rid of the cycle."

    PackageProblem msg ->
        hPutStrLn stderr msg

    MissingPackage name ->
        hPutStrLn stderr $
          "Could not find package " ++ Pkg.toString name ++ ".\n"
          ++ "\n"
          ++ "Maybe your elm-stuff/ directory has been corrupted? You can usually fix stuff\n"
          ++ "like this by deleting elm-stuff/ and rebuilding your project."

    ModuleNotFound name maybeParent ->
        hPutStrLn stderr $
          "I cannot find module '" ++ Module.nameToString name ++ "'.\n"
          ++ "\n"
          ++ toContext maybeParent
          ++ "\n"
          ++ "Potential problems could be:\n"
          ++ "  * Misspelled the module name\n"
          ++ "  * Need to add a source directory or new dependency to " ++ Path.description

    ModuleDuplicates name maybeParent filePaths pkgs ->
        let
          packages =
            map ("package " ++) (map Pkg.toString pkgs)

          paths =
            map ("directory " ++) filePaths
        in
          hPutStrLn stderr $
            "I found multiple modules named '" ++ Module.nameToString name ++ "'.\n"
            ++ "\n"
            ++ toContext maybeParent
            ++ "\n"
            ++ "Modules with that name were found in the following locations:\n\n" ++
            concatMap (\str -> "    " ++ str ++ "\n") (paths ++ packages)

    ModuleName path nameFromPath nameFromSource ->
        hPutStrLn stderr $
          "The module name is messed up for " ++ path ++ "\n"
          ++ "\n"
          ++ "    According to the file's name it should be " ++ Module.nameToString nameFromPath ++ "\n"
          ++ "    According to the source code it should be " ++ Module.nameToString nameFromSource ++ "\n"
          ++ "\n"
          ++ "Which is it?"


toContext :: Maybe Module.Name -> String
toContext maybeParent =
  case maybeParent of
    Nothing ->
        "This module is demanded in " ++ Path.description ++ ".\n"

    Just parent ->
        "Module '" ++ Module.nameToString parent ++ "' is trying to import it.\n"


drawCycle :: [TMP.CanonicalModule] -> String
drawCycle modules =
  let
    topLine=
        [ "  ┌─────┐"
        , "  │     V"
        ]

    line (TMP.CanonicalModule _ name) =
        [ "  │    " ++ Module.nameToString name ]

    midLine =
        [ "  │     │"
        , "  │     V"
        ]

    bottomLine =
        "  └─────┘"
  in
    unlines (topLine ++ List.intercalate midLine (map line modules) ++ [ bottomLine ])

